import {
  session,
  app,
  BrowserWindow,
  nativeTheme,
  Menu,
  autoUpdater,
  dialog,
} from "electron";
import * as Rx from "rxjs";

import { initIpcRouter } from "main/ipcRouter";
import { Config } from "main/config";
import { RepoCollection } from "main/repos";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let currentMainWindow: BrowserWindow | null = null;
const createWindow = (config: Config): void => {
  if (currentMainWindow) {
    currentMainWindow.show();
    return;
  }

  Rx.firstValueFrom(config.get$("windowBounds")).then((oldBounds) => {
    if (currentMainWindow) {
      currentMainWindow.show();
      return;
    }

    // Create the browser window.
    const mainWindow = (currentMainWindow = new BrowserWindow({
      height: oldBounds?.height || 1000,
      width: oldBounds?.width || 1200,
      x: oldBounds?.x,
      y: oldBounds?.y,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        nodeIntegration: true,
        contextIsolation: false,
      },
    }));

    // auto persist window bounds to config
    Rx.merge(
      Rx.fromEvent(mainWindow, "resized"),
      Rx.fromEvent(mainWindow, "moved")
    )
      .pipe(
        Rx.debounceTime(1000),
        Rx.mergeMap(() =>
          config.update$({
            windowBounds: mainWindow.getBounds(),
          })
        ),
        Rx.catchError((error, source$) => {
          console.error("Failed to persist window bounds", error);
          return source$;
        })
      )
      .subscribe();

    Rx.fromEvent(mainWindow, "close").subscribe(() => {
      currentMainWindow = null;
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  });
};

async function init() {
  const updateUrl = `https://update.electronjs.org/spalger/localgnome/${
    process.platform
  }-${process.arch}/${app.getVersion()}`;
  const updateHeaders = { "User-Agent": "spalger/localgnome" };
  autoUpdater.setFeedURL({ url: updateUrl, headers: updateHeaders });

  if (app.isPackaged) {
    autoUpdater.checkForUpdates();
  }

  autoUpdater.on("update-downloaded", (_, releaseNotes, releaseName) => {
    dialog
      .showMessageBox({
        type: "info",
        buttons: ["Restart", "Later"],
        title: "Application Update",
        message: process.platform === "win32" ? releaseNotes : releaseName,
        detail:
          "A new version has been downloaded. Restart the application to apply the updates.",
      })
      .then(({ response }) => {
        if (response !== 0) return;
        autoUpdater.quitAndInstall();
      });
  });

  await app.whenReady();

  const menu = Menu.buildFromTemplate([
    {
      label: app.name,
      submenu: [
        { role: "about" },
        { type: "separator" },
        { role: "services" },
        { type: "separator" },
        { role: "hide" },
        { role: "hideOthers" },
        { role: "unhide" },
        { type: "separator" },
        {
          label: "Check for update",
          click: () =>
            Rx.race(
              Rx.defer(() => {
                autoUpdater.checkForUpdates();
                return Rx.NEVER;
              }),
              Rx.fromEvent(autoUpdater, "update-available").pipe(
                Rx.map(() => "update-available" as const)
              ),
              Rx.fromEvent(autoUpdater, "update-not-available").pipe(
                Rx.map(() => "update-not-available" as const)
              )
            ).subscribe({
              next: (event) => {
                if (event === "update-not-available") {
                  dialog.showMessageBox({
                    type: "info",
                    buttons: ["OK"],
                    title: "Check for update",
                    message: "No update available at this time",
                  });
                }
              },
            }),
        },
        { type: "separator" },
        { role: "quit" },
      ],
    },
    { role: "fileMenu" },
    { role: "viewMenu" },
    {
      role: "windowMenu",
      submenu: [
        {
          label: "Main view",
          accelerator: "CmdOrCtrl+1",
          registerAccelerator: true,
          click: () => {
            createWindow(config);
          },
        },
        { type: "separator" },
        { role: "minimize" },
        { role: "zoom" },
        { type: "separator" },
        { role: "front" },
        { type: "separator" },
        { role: "window" },
      ],
    },
  ]);
  Menu.setApplicationMenu(menu);

  // ensure that CSP is set to the most restrictive value
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": ["script-src 'self'"],
      },
    });
  });

  // Quit when all windows are closed, except on macOS. There, it's common
  // for applications and their menu bar to stay active until the user quits
  // explicitly with Cmd + Q.
  app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
      app.quit();
    }
  });

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow(config);
    }
  });

  const config = new Config();
  const repos = new RepoCollection(config);

  // bind the config to electron modules
  config
    .get$("theme")
    .pipe(
      Rx.map((theme) => {
        nativeTheme.themeSource = theme ?? "system";
      })
    )
    .subscribe({
      error(error) {
        console.error("Failed to set theme", error);
        process.exit(1);
      },
    });

  await initIpcRouter({
    config,
    repos,
  });

  createWindow(config);
}

init().catch((error) => {
  console.error("UNCAUGHT EXCEPTION", error);
  process.exit(1);
});
